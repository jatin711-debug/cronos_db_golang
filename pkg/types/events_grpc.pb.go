// Code generated by protoc-gen-go-grpc. DO NOT EDIT.
// versions:
// - protoc-gen-go-grpc v1.5.1
// - protoc             v5.29.3
// source: proto/events.proto

package types

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
// Requires gRPC-Go v1.64.0 or later.
const _ = grpc.SupportPackageIsVersion9

const (
	EventService_Publish_FullMethodName   = "/cronos_db.EventService/Publish"
	EventService_Subscribe_FullMethodName = "/cronos_db.EventService/Subscribe"
	EventService_Ack_FullMethodName       = "/cronos_db.EventService/Ack"
	EventService_Replay_FullMethodName    = "/cronos_db.EventService/Replay"
)

// EventServiceClient is the client API for EventService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type EventServiceClient interface {
	// Publish an event
	Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error)
	// Subscribe to events (streaming)
	Subscribe(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SubscribeRequest, Delivery], error)
	// Acknowledge event processing
	Ack(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AckRequest, AckResponse], error)
	// Replay historical events
	Replay(ctx context.Context, in *ReplayRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReplayEvent], error)
}

type eventServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewEventServiceClient(cc grpc.ClientConnInterface) EventServiceClient {
	return &eventServiceClient{cc}
}

func (c *eventServiceClient) Publish(ctx context.Context, in *PublishRequest, opts ...grpc.CallOption) (*PublishResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PublishResponse)
	err := c.cc.Invoke(ctx, EventService_Publish_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *eventServiceClient) Subscribe(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[SubscribeRequest, Delivery], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[0], EventService_Subscribe_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[SubscribeRequest, Delivery]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_SubscribeClient = grpc.BidiStreamingClient[SubscribeRequest, Delivery]

func (c *eventServiceClient) Ack(ctx context.Context, opts ...grpc.CallOption) (grpc.BidiStreamingClient[AckRequest, AckResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[1], EventService_Ack_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[AckRequest, AckResponse]{ClientStream: stream}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_AckClient = grpc.BidiStreamingClient[AckRequest, AckResponse]

func (c *eventServiceClient) Replay(ctx context.Context, in *ReplayRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReplayEvent], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &EventService_ServiceDesc.Streams[2], EventService_Replay_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReplayRequest, ReplayEvent]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ReplayClient = grpc.ServerStreamingClient[ReplayEvent]

// EventServiceServer is the server API for EventService service.
// All implementations must embed UnimplementedEventServiceServer
// for forward compatibility.
type EventServiceServer interface {
	// Publish an event
	Publish(context.Context, *PublishRequest) (*PublishResponse, error)
	// Subscribe to events (streaming)
	Subscribe(grpc.BidiStreamingServer[SubscribeRequest, Delivery]) error
	// Acknowledge event processing
	Ack(grpc.BidiStreamingServer[AckRequest, AckResponse]) error
	// Replay historical events
	Replay(*ReplayRequest, grpc.ServerStreamingServer[ReplayEvent]) error
	mustEmbedUnimplementedEventServiceServer()
}

// UnimplementedEventServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedEventServiceServer struct{}

func (UnimplementedEventServiceServer) Publish(context.Context, *PublishRequest) (*PublishResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Publish not implemented")
}
func (UnimplementedEventServiceServer) Subscribe(grpc.BidiStreamingServer[SubscribeRequest, Delivery]) error {
	return status.Errorf(codes.Unimplemented, "method Subscribe not implemented")
}
func (UnimplementedEventServiceServer) Ack(grpc.BidiStreamingServer[AckRequest, AckResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Ack not implemented")
}
func (UnimplementedEventServiceServer) Replay(*ReplayRequest, grpc.ServerStreamingServer[ReplayEvent]) error {
	return status.Errorf(codes.Unimplemented, "method Replay not implemented")
}
func (UnimplementedEventServiceServer) mustEmbedUnimplementedEventServiceServer() {}
func (UnimplementedEventServiceServer) testEmbeddedByValue()                      {}

// UnsafeEventServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to EventServiceServer will
// result in compilation errors.
type UnsafeEventServiceServer interface {
	mustEmbedUnimplementedEventServiceServer()
}

func RegisterEventServiceServer(s grpc.ServiceRegistrar, srv EventServiceServer) {
	// If the following call pancis, it indicates UnimplementedEventServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&EventService_ServiceDesc, srv)
}

func _EventService_Publish_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PublishRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(EventServiceServer).Publish(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: EventService_Publish_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(EventServiceServer).Publish(ctx, req.(*PublishRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _EventService_Subscribe_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventServiceServer).Subscribe(&grpc.GenericServerStream[SubscribeRequest, Delivery]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_SubscribeServer = grpc.BidiStreamingServer[SubscribeRequest, Delivery]

func _EventService_Ack_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(EventServiceServer).Ack(&grpc.GenericServerStream[AckRequest, AckResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_AckServer = grpc.BidiStreamingServer[AckRequest, AckResponse]

func _EventService_Replay_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReplayRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(EventServiceServer).Replay(m, &grpc.GenericServerStream[ReplayRequest, ReplayEvent]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type EventService_ReplayServer = grpc.ServerStreamingServer[ReplayEvent]

// EventService_ServiceDesc is the grpc.ServiceDesc for EventService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var EventService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cronos_db.EventService",
	HandlerType: (*EventServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Publish",
			Handler:    _EventService_Publish_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Subscribe",
			Handler:       _EventService_Subscribe_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Ack",
			Handler:       _EventService_Ack_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
		{
			StreamName:    "Replay",
			Handler:       _EventService_Replay_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/events.proto",
}

const (
	PartitionService_GetPartition_FullMethodName       = "/cronos_db.PartitionService/GetPartition"
	PartitionService_ListPartitions_FullMethodName     = "/cronos_db.PartitionService/ListPartitions"
	PartitionService_GetWALStatus_FullMethodName       = "/cronos_db.PartitionService/GetWALStatus"
	PartitionService_GetSchedulerStatus_FullMethodName = "/cronos_db.PartitionService/GetSchedulerStatus"
	PartitionService_Compact_FullMethodName            = "/cronos_db.PartitionService/Compact"
	PartitionService_RunRetention_FullMethodName       = "/cronos_db.PartitionService/RunRetention"
)

// PartitionServiceClient is the client API for PartitionService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type PartitionServiceClient interface {
	// Get partition information
	GetPartition(ctx context.Context, in *GetPartitionRequest, opts ...grpc.CallOption) (*PartitionInfo, error)
	// List partitions
	ListPartitions(ctx context.Context, in *ListPartitionsRequest, opts ...grpc.CallOption) (*ListPartitionsResponse, error)
	// Get WAL status
	GetWALStatus(ctx context.Context, in *GetWALStatusRequest, opts ...grpc.CallOption) (*WALStatus, error)
	// Get scheduler status
	GetSchedulerStatus(ctx context.Context, in *GetSchedulerStatusRequest, opts ...grpc.CallOption) (*SchedulerStatus, error)
	// Compact segments
	Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error)
	// Run retention policy
	RunRetention(ctx context.Context, in *RetentionRequest, opts ...grpc.CallOption) (*RetentionResponse, error)
}

type partitionServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewPartitionServiceClient(cc grpc.ClientConnInterface) PartitionServiceClient {
	return &partitionServiceClient{cc}
}

func (c *partitionServiceClient) GetPartition(ctx context.Context, in *GetPartitionRequest, opts ...grpc.CallOption) (*PartitionInfo, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(PartitionInfo)
	err := c.cc.Invoke(ctx, PartitionService_GetPartition_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) ListPartitions(ctx context.Context, in *ListPartitionsRequest, opts ...grpc.CallOption) (*ListPartitionsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListPartitionsResponse)
	err := c.cc.Invoke(ctx, PartitionService_ListPartitions_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) GetWALStatus(ctx context.Context, in *GetWALStatusRequest, opts ...grpc.CallOption) (*WALStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(WALStatus)
	err := c.cc.Invoke(ctx, PartitionService_GetWALStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) GetSchedulerStatus(ctx context.Context, in *GetSchedulerStatusRequest, opts ...grpc.CallOption) (*SchedulerStatus, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(SchedulerStatus)
	err := c.cc.Invoke(ctx, PartitionService_GetSchedulerStatus_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) Compact(ctx context.Context, in *CompactRequest, opts ...grpc.CallOption) (*CompactResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CompactResponse)
	err := c.cc.Invoke(ctx, PartitionService_Compact_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *partitionServiceClient) RunRetention(ctx context.Context, in *RetentionRequest, opts ...grpc.CallOption) (*RetentionResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RetentionResponse)
	err := c.cc.Invoke(ctx, PartitionService_RunRetention_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// PartitionServiceServer is the server API for PartitionService service.
// All implementations must embed UnimplementedPartitionServiceServer
// for forward compatibility.
type PartitionServiceServer interface {
	// Get partition information
	GetPartition(context.Context, *GetPartitionRequest) (*PartitionInfo, error)
	// List partitions
	ListPartitions(context.Context, *ListPartitionsRequest) (*ListPartitionsResponse, error)
	// Get WAL status
	GetWALStatus(context.Context, *GetWALStatusRequest) (*WALStatus, error)
	// Get scheduler status
	GetSchedulerStatus(context.Context, *GetSchedulerStatusRequest) (*SchedulerStatus, error)
	// Compact segments
	Compact(context.Context, *CompactRequest) (*CompactResponse, error)
	// Run retention policy
	RunRetention(context.Context, *RetentionRequest) (*RetentionResponse, error)
	mustEmbedUnimplementedPartitionServiceServer()
}

// UnimplementedPartitionServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedPartitionServiceServer struct{}

func (UnimplementedPartitionServiceServer) GetPartition(context.Context, *GetPartitionRequest) (*PartitionInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetPartition not implemented")
}
func (UnimplementedPartitionServiceServer) ListPartitions(context.Context, *ListPartitionsRequest) (*ListPartitionsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListPartitions not implemented")
}
func (UnimplementedPartitionServiceServer) GetWALStatus(context.Context, *GetWALStatusRequest) (*WALStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetWALStatus not implemented")
}
func (UnimplementedPartitionServiceServer) GetSchedulerStatus(context.Context, *GetSchedulerStatusRequest) (*SchedulerStatus, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetSchedulerStatus not implemented")
}
func (UnimplementedPartitionServiceServer) Compact(context.Context, *CompactRequest) (*CompactResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Compact not implemented")
}
func (UnimplementedPartitionServiceServer) RunRetention(context.Context, *RetentionRequest) (*RetentionResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RunRetention not implemented")
}
func (UnimplementedPartitionServiceServer) mustEmbedUnimplementedPartitionServiceServer() {}
func (UnimplementedPartitionServiceServer) testEmbeddedByValue()                          {}

// UnsafePartitionServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to PartitionServiceServer will
// result in compilation errors.
type UnsafePartitionServiceServer interface {
	mustEmbedUnimplementedPartitionServiceServer()
}

func RegisterPartitionServiceServer(s grpc.ServiceRegistrar, srv PartitionServiceServer) {
	// If the following call pancis, it indicates UnimplementedPartitionServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&PartitionService_ServiceDesc, srv)
}

func _PartitionService_GetPartition_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetPartitionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).GetPartition(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PartitionService_GetPartition_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).GetPartition(ctx, req.(*GetPartitionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_ListPartitions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPartitionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).ListPartitions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PartitionService_ListPartitions_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).ListPartitions(ctx, req.(*ListPartitionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_GetWALStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetWALStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).GetWALStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PartitionService_GetWALStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).GetWALStatus(ctx, req.(*GetWALStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_GetSchedulerStatus_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetSchedulerStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).GetSchedulerStatus(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PartitionService_GetSchedulerStatus_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).GetSchedulerStatus(ctx, req.(*GetSchedulerStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_Compact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CompactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).Compact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PartitionService_Compact_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).Compact(ctx, req.(*CompactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PartitionService_RunRetention_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RetentionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PartitionServiceServer).RunRetention(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: PartitionService_RunRetention_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PartitionServiceServer).RunRetention(ctx, req.(*RetentionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// PartitionService_ServiceDesc is the grpc.ServiceDesc for PartitionService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var PartitionService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cronos_db.PartitionService",
	HandlerType: (*PartitionServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "GetPartition",
			Handler:    _PartitionService_GetPartition_Handler,
		},
		{
			MethodName: "ListPartitions",
			Handler:    _PartitionService_ListPartitions_Handler,
		},
		{
			MethodName: "GetWALStatus",
			Handler:    _PartitionService_GetWALStatus_Handler,
		},
		{
			MethodName: "GetSchedulerStatus",
			Handler:    _PartitionService_GetSchedulerStatus_Handler,
		},
		{
			MethodName: "Compact",
			Handler:    _PartitionService_Compact_Handler,
		},
		{
			MethodName: "RunRetention",
			Handler:    _PartitionService_RunRetention_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/events.proto",
}

const (
	ConsumerGroupService_CreateConsumerGroup_FullMethodName    = "/cronos_db.ConsumerGroupService/CreateConsumerGroup"
	ConsumerGroupService_GetConsumerGroup_FullMethodName       = "/cronos_db.ConsumerGroupService/GetConsumerGroup"
	ConsumerGroupService_ListConsumerGroups_FullMethodName     = "/cronos_db.ConsumerGroupService/ListConsumerGroups"
	ConsumerGroupService_RebalanceConsumerGroup_FullMethodName = "/cronos_db.ConsumerGroupService/RebalanceConsumerGroup"
)

// ConsumerGroupServiceClient is the client API for ConsumerGroupService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ConsumerGroupServiceClient interface {
	// Create consumer group
	CreateConsumerGroup(ctx context.Context, in *CreateConsumerGroupRequest, opts ...grpc.CallOption) (*CreateConsumerGroupResponse, error)
	// Get consumer group info
	GetConsumerGroup(ctx context.Context, in *GetConsumerGroupRequest, opts ...grpc.CallOption) (*ConsumerGroupMetadata, error)
	// List consumer groups
	ListConsumerGroups(ctx context.Context, in *ListConsumerGroupsRequest, opts ...grpc.CallOption) (*ListConsumerGroupsResponse, error)
	// Rebalance consumer group
	RebalanceConsumerGroup(ctx context.Context, in *RebalanceConsumerGroupRequest, opts ...grpc.CallOption) (*RebalanceConsumerGroupResponse, error)
}

type consumerGroupServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewConsumerGroupServiceClient(cc grpc.ClientConnInterface) ConsumerGroupServiceClient {
	return &consumerGroupServiceClient{cc}
}

func (c *consumerGroupServiceClient) CreateConsumerGroup(ctx context.Context, in *CreateConsumerGroupRequest, opts ...grpc.CallOption) (*CreateConsumerGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(CreateConsumerGroupResponse)
	err := c.cc.Invoke(ctx, ConsumerGroupService_CreateConsumerGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consumerGroupServiceClient) GetConsumerGroup(ctx context.Context, in *GetConsumerGroupRequest, opts ...grpc.CallOption) (*ConsumerGroupMetadata, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ConsumerGroupMetadata)
	err := c.cc.Invoke(ctx, ConsumerGroupService_GetConsumerGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consumerGroupServiceClient) ListConsumerGroups(ctx context.Context, in *ListConsumerGroupsRequest, opts ...grpc.CallOption) (*ListConsumerGroupsResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ListConsumerGroupsResponse)
	err := c.cc.Invoke(ctx, ConsumerGroupService_ListConsumerGroups_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *consumerGroupServiceClient) RebalanceConsumerGroup(ctx context.Context, in *RebalanceConsumerGroupRequest, opts ...grpc.CallOption) (*RebalanceConsumerGroupResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RebalanceConsumerGroupResponse)
	err := c.cc.Invoke(ctx, ConsumerGroupService_RebalanceConsumerGroup_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ConsumerGroupServiceServer is the server API for ConsumerGroupService service.
// All implementations must embed UnimplementedConsumerGroupServiceServer
// for forward compatibility.
type ConsumerGroupServiceServer interface {
	// Create consumer group
	CreateConsumerGroup(context.Context, *CreateConsumerGroupRequest) (*CreateConsumerGroupResponse, error)
	// Get consumer group info
	GetConsumerGroup(context.Context, *GetConsumerGroupRequest) (*ConsumerGroupMetadata, error)
	// List consumer groups
	ListConsumerGroups(context.Context, *ListConsumerGroupsRequest) (*ListConsumerGroupsResponse, error)
	// Rebalance consumer group
	RebalanceConsumerGroup(context.Context, *RebalanceConsumerGroupRequest) (*RebalanceConsumerGroupResponse, error)
	mustEmbedUnimplementedConsumerGroupServiceServer()
}

// UnimplementedConsumerGroupServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedConsumerGroupServiceServer struct{}

func (UnimplementedConsumerGroupServiceServer) CreateConsumerGroup(context.Context, *CreateConsumerGroupRequest) (*CreateConsumerGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method CreateConsumerGroup not implemented")
}
func (UnimplementedConsumerGroupServiceServer) GetConsumerGroup(context.Context, *GetConsumerGroupRequest) (*ConsumerGroupMetadata, error) {
	return nil, status.Errorf(codes.Unimplemented, "method GetConsumerGroup not implemented")
}
func (UnimplementedConsumerGroupServiceServer) ListConsumerGroups(context.Context, *ListConsumerGroupsRequest) (*ListConsumerGroupsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method ListConsumerGroups not implemented")
}
func (UnimplementedConsumerGroupServiceServer) RebalanceConsumerGroup(context.Context, *RebalanceConsumerGroupRequest) (*RebalanceConsumerGroupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RebalanceConsumerGroup not implemented")
}
func (UnimplementedConsumerGroupServiceServer) mustEmbedUnimplementedConsumerGroupServiceServer() {}
func (UnimplementedConsumerGroupServiceServer) testEmbeddedByValue()                              {}

// UnsafeConsumerGroupServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ConsumerGroupServiceServer will
// result in compilation errors.
type UnsafeConsumerGroupServiceServer interface {
	mustEmbedUnimplementedConsumerGroupServiceServer()
}

func RegisterConsumerGroupServiceServer(s grpc.ServiceRegistrar, srv ConsumerGroupServiceServer) {
	// If the following call pancis, it indicates UnimplementedConsumerGroupServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ConsumerGroupService_ServiceDesc, srv)
}

func _ConsumerGroupService_CreateConsumerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateConsumerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerGroupServiceServer).CreateConsumerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsumerGroupService_CreateConsumerGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerGroupServiceServer).CreateConsumerGroup(ctx, req.(*CreateConsumerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsumerGroupService_GetConsumerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GetConsumerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerGroupServiceServer).GetConsumerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsumerGroupService_GetConsumerGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerGroupServiceServer).GetConsumerGroup(ctx, req.(*GetConsumerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsumerGroupService_ListConsumerGroups_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListConsumerGroupsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerGroupServiceServer).ListConsumerGroups(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsumerGroupService_ListConsumerGroups_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerGroupServiceServer).ListConsumerGroups(ctx, req.(*ListConsumerGroupsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ConsumerGroupService_RebalanceConsumerGroup_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RebalanceConsumerGroupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConsumerGroupServiceServer).RebalanceConsumerGroup(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ConsumerGroupService_RebalanceConsumerGroup_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConsumerGroupServiceServer).RebalanceConsumerGroup(ctx, req.(*RebalanceConsumerGroupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// ConsumerGroupService_ServiceDesc is the grpc.ServiceDesc for ConsumerGroupService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ConsumerGroupService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cronos_db.ConsumerGroupService",
	HandlerType: (*ConsumerGroupServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateConsumerGroup",
			Handler:    _ConsumerGroupService_CreateConsumerGroup_Handler,
		},
		{
			MethodName: "GetConsumerGroup",
			Handler:    _ConsumerGroupService_GetConsumerGroup_Handler,
		},
		{
			MethodName: "ListConsumerGroups",
			Handler:    _ConsumerGroupService_ListConsumerGroups_Handler,
		},
		{
			MethodName: "RebalanceConsumerGroup",
			Handler:    _ConsumerGroupService_RebalanceConsumerGroup_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/events.proto",
}

const (
	ReplicationService_Append_FullMethodName = "/cronos_db.ReplicationService/Append"
	ReplicationService_Sync_FullMethodName   = "/cronos_db.ReplicationService/Sync"
)

// ReplicationServiceClient is the client API for ReplicationService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ReplicationServiceClient interface {
	// Internal: Append batch from leader
	Append(ctx context.Context, in *ReplicationAppendRequest, opts ...grpc.CallOption) (*ReplicationAppendResponse, error)
	// Internal: Sync from leader
	Sync(ctx context.Context, in *ReplicationSyncRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReplicationSyncResponse], error)
}

type replicationServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewReplicationServiceClient(cc grpc.ClientConnInterface) ReplicationServiceClient {
	return &replicationServiceClient{cc}
}

func (c *replicationServiceClient) Append(ctx context.Context, in *ReplicationAppendRequest, opts ...grpc.CallOption) (*ReplicationAppendResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(ReplicationAppendResponse)
	err := c.cc.Invoke(ctx, ReplicationService_Append_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *replicationServiceClient) Sync(ctx context.Context, in *ReplicationSyncRequest, opts ...grpc.CallOption) (grpc.ServerStreamingClient[ReplicationSyncResponse], error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	stream, err := c.cc.NewStream(ctx, &ReplicationService_ServiceDesc.Streams[0], ReplicationService_Sync_FullMethodName, cOpts...)
	if err != nil {
		return nil, err
	}
	x := &grpc.GenericClientStream[ReplicationSyncRequest, ReplicationSyncResponse]{ClientStream: stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplicationService_SyncClient = grpc.ServerStreamingClient[ReplicationSyncResponse]

// ReplicationServiceServer is the server API for ReplicationService service.
// All implementations must embed UnimplementedReplicationServiceServer
// for forward compatibility.
type ReplicationServiceServer interface {
	// Internal: Append batch from leader
	Append(context.Context, *ReplicationAppendRequest) (*ReplicationAppendResponse, error)
	// Internal: Sync from leader
	Sync(*ReplicationSyncRequest, grpc.ServerStreamingServer[ReplicationSyncResponse]) error
	mustEmbedUnimplementedReplicationServiceServer()
}

// UnimplementedReplicationServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedReplicationServiceServer struct{}

func (UnimplementedReplicationServiceServer) Append(context.Context, *ReplicationAppendRequest) (*ReplicationAppendResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Append not implemented")
}
func (UnimplementedReplicationServiceServer) Sync(*ReplicationSyncRequest, grpc.ServerStreamingServer[ReplicationSyncResponse]) error {
	return status.Errorf(codes.Unimplemented, "method Sync not implemented")
}
func (UnimplementedReplicationServiceServer) mustEmbedUnimplementedReplicationServiceServer() {}
func (UnimplementedReplicationServiceServer) testEmbeddedByValue()                            {}

// UnsafeReplicationServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to ReplicationServiceServer will
// result in compilation errors.
type UnsafeReplicationServiceServer interface {
	mustEmbedUnimplementedReplicationServiceServer()
}

func RegisterReplicationServiceServer(s grpc.ServiceRegistrar, srv ReplicationServiceServer) {
	// If the following call pancis, it indicates UnimplementedReplicationServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&ReplicationService_ServiceDesc, srv)
}

func _ReplicationService_Append_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ReplicationAppendRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ReplicationServiceServer).Append(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: ReplicationService_Append_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ReplicationServiceServer).Append(ctx, req.(*ReplicationAppendRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ReplicationService_Sync_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReplicationSyncRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ReplicationServiceServer).Sync(m, &grpc.GenericServerStream[ReplicationSyncRequest, ReplicationSyncResponse]{ServerStream: stream})
}

// This type alias is provided for backwards compatibility with existing code that references the prior non-generic stream type by name.
type ReplicationService_SyncServer = grpc.ServerStreamingServer[ReplicationSyncResponse]

// ReplicationService_ServiceDesc is the grpc.ServiceDesc for ReplicationService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var ReplicationService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cronos_db.ReplicationService",
	HandlerType: (*ReplicationServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Append",
			Handler:    _ReplicationService_Append_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Sync",
			Handler:       _ReplicationService_Sync_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "proto/events.proto",
}

const (
	RaftService_Join_FullMethodName   = "/cronos_db.RaftService/Join"
	RaftService_Leave_FullMethodName  = "/cronos_db.RaftService/Leave"
	RaftService_Status_FullMethodName = "/cronos_db.RaftService/Status"
)

// RaftServiceClient is the client API for RaftService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type RaftServiceClient interface {
	// Internal: Join cluster
	Join(ctx context.Context, in *RaftJoinRequest, opts ...grpc.CallOption) (*RaftJoinResponse, error)
	// Internal: Leave cluster
	Leave(ctx context.Context, in *RaftLeaveRequest, opts ...grpc.CallOption) (*RaftLeaveResponse, error)
	// Internal: Get raft status
	Status(ctx context.Context, in *RaftStatusRequest, opts ...grpc.CallOption) (*RaftStatusResponse, error)
}

type raftServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewRaftServiceClient(cc grpc.ClientConnInterface) RaftServiceClient {
	return &raftServiceClient{cc}
}

func (c *raftServiceClient) Join(ctx context.Context, in *RaftJoinRequest, opts ...grpc.CallOption) (*RaftJoinResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RaftJoinResponse)
	err := c.cc.Invoke(ctx, RaftService_Join_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) Leave(ctx context.Context, in *RaftLeaveRequest, opts ...grpc.CallOption) (*RaftLeaveResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RaftLeaveResponse)
	err := c.cc.Invoke(ctx, RaftService_Leave_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *raftServiceClient) Status(ctx context.Context, in *RaftStatusRequest, opts ...grpc.CallOption) (*RaftStatusResponse, error) {
	cOpts := append([]grpc.CallOption{grpc.StaticMethod()}, opts...)
	out := new(RaftStatusResponse)
	err := c.cc.Invoke(ctx, RaftService_Status_FullMethodName, in, out, cOpts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RaftServiceServer is the server API for RaftService service.
// All implementations must embed UnimplementedRaftServiceServer
// for forward compatibility.
type RaftServiceServer interface {
	// Internal: Join cluster
	Join(context.Context, *RaftJoinRequest) (*RaftJoinResponse, error)
	// Internal: Leave cluster
	Leave(context.Context, *RaftLeaveRequest) (*RaftLeaveResponse, error)
	// Internal: Get raft status
	Status(context.Context, *RaftStatusRequest) (*RaftStatusResponse, error)
	mustEmbedUnimplementedRaftServiceServer()
}

// UnimplementedRaftServiceServer must be embedded to have
// forward compatible implementations.
//
// NOTE: this should be embedded by value instead of pointer to avoid a nil
// pointer dereference when methods are called.
type UnimplementedRaftServiceServer struct{}

func (UnimplementedRaftServiceServer) Join(context.Context, *RaftJoinRequest) (*RaftJoinResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Join not implemented")
}
func (UnimplementedRaftServiceServer) Leave(context.Context, *RaftLeaveRequest) (*RaftLeaveResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Leave not implemented")
}
func (UnimplementedRaftServiceServer) Status(context.Context, *RaftStatusRequest) (*RaftStatusResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Status not implemented")
}
func (UnimplementedRaftServiceServer) mustEmbedUnimplementedRaftServiceServer() {}
func (UnimplementedRaftServiceServer) testEmbeddedByValue()                     {}

// UnsafeRaftServiceServer may be embedded to opt out of forward compatibility for this service.
// Use of this interface is not recommended, as added methods to RaftServiceServer will
// result in compilation errors.
type UnsafeRaftServiceServer interface {
	mustEmbedUnimplementedRaftServiceServer()
}

func RegisterRaftServiceServer(s grpc.ServiceRegistrar, srv RaftServiceServer) {
	// If the following call pancis, it indicates UnimplementedRaftServiceServer was
	// embedded by pointer and is nil.  This will cause panics if an
	// unimplemented method is ever invoked, so we test this at initialization
	// time to prevent it from happening at runtime later due to I/O.
	if t, ok := srv.(interface{ testEmbeddedByValue() }); ok {
		t.testEmbeddedByValue()
	}
	s.RegisterService(&RaftService_ServiceDesc, srv)
}

func _RaftService_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftJoinRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RaftService_Join_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Join(ctx, req.(*RaftJoinRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_Leave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftLeaveRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Leave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RaftService_Leave_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Leave(ctx, req.(*RaftLeaveRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _RaftService_Status_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RaftStatusRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RaftServiceServer).Status(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: RaftService_Status_FullMethodName,
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RaftServiceServer).Status(ctx, req.(*RaftStatusRequest))
	}
	return interceptor(ctx, in, info, handler)
}

// RaftService_ServiceDesc is the grpc.ServiceDesc for RaftService service.
// It's only intended for direct use with grpc.RegisterService,
// and not to be introspected or modified (even as a copy)
var RaftService_ServiceDesc = grpc.ServiceDesc{
	ServiceName: "cronos_db.RaftService",
	HandlerType: (*RaftServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Join",
			Handler:    _RaftService_Join_Handler,
		},
		{
			MethodName: "Leave",
			Handler:    _RaftService_Leave_Handler,
		},
		{
			MethodName: "Status",
			Handler:    _RaftService_Status_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "proto/events.proto",
}
